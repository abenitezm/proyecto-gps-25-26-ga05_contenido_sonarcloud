/*
 * Microservicio de Contenido - UnderSounds
 *
 * Este microservicio gestiona el contenido multimedia y comercial del proyecto \"UnderSounds\", incluyendo albumes, canciones, generos, merchandising y noticias musicales.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */
package openapi

import (
    "database/sql"
    "net/http"
    "strconv"
    "strings"

    "github.com/gin-gonic/gin"
)

type SearchAPI struct {
    DB *sql.DB
}



// GET /busqueda
// Params: q (nombre), genero (id o nombre), type (albumes|canciones|merch|artistas), page, per_page
func (api *SearchAPI) BusquedaGet(c *gin.Context) {
    q := strings.TrimSpace(c.Query("q"))
    generoParam := strings.TrimSpace(c.Query("genero"))
    typ := strings.TrimSpace(strings.ToLower(c.Query("type")))

    pageStr := c.DefaultQuery("page", "1")
    perPageStr := c.DefaultQuery("per_page", "10")
    page, _ := strconv.Atoi(pageStr)
    perPage, _ := strconv.Atoi(perPageStr)
    if page < 1 {
        page = 1
    }
    if perPage < 1 || perPage > 100 {
        perPage = 10
    }
    // pagination handled inside repo functions; no local offset needed

    // resolve genero param to id if given as name or id
    generoID, _ := ResolveGeneroID(api.DB, generoParam)

    resp := SearchResponse{
        Page:    page,
        PerPage: perPage,
        Totals:  map[string]int{},
        Results: map[string]interface{}{},
    }

    // Search albums
    if typ == "" || typ == "albumes" {
        albums, total, err := SearchAlbums(api.DB, q, generoID, page, perPage)
        if err != nil { albums = []AlbumResult{} }
        resp.Totals["albumes"] = total
        resp.Results["albumes"] = albums
    }

    // Search canciones
    if typ == "" || typ == "canciones" {
        songs, total, err := SearchCanciones(api.DB, q, generoID, page, perPage)
        if err != nil { songs = []CancionResult{} }
        resp.Totals["canciones"] = total
        resp.Results["canciones"] = songs
    }

    // Search merch
    if typ == "" || typ == "merch" || typ == "merchandising" {
        merchs, total, err := SearchMerch(api.DB, q, page, perPage)
        if err != nil { merchs = []Merch{} }
        resp.Totals["merch"] = total
        resp.Results["merch"] = merchs
    }

    // Search artists (by id present in tables)
    if typ == "" || typ == "artistas" {
        artists, total, err := SearchArtistas(api.DB, q, generoID)
        if err != nil { artists = []ArtistResult{} }
        resp.Totals["artistas"] = total
        resp.Results["artistas"] = artists
    }

    // If everything empty, return message
    empty := true
    for _, v := range resp.Results {
        switch vv := v.(type) {
        case []AlbumResult:
            if len(vv) > 0 { empty = false }
        case []CancionResult:
            if len(vv) > 0 { empty = false }
        case []Merch:
            if len(vv) > 0 { empty = false }
        case []ArtistResult:
            if len(vv) > 0 { empty = false }
        default:
            if v != nil { empty = false }
        }
    }

    if empty {
        c.JSON(http.StatusOK, gin.H{"status": "OK", "message": "No se encontraron coincidencias", "data": resp})
        return
    }

    c.JSON(http.StatusOK, gin.H{"status": "OK", "data": resp})
}
