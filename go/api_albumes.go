/*
 * Microservicio de Contenido - UnderSounds
 *
 * Este microservicio gestiona el contenido multimedia y comercial del proyecto \"UnderSounds\", incluyendo albumes, canciones, generos, merchandising y noticias musicales.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

// ERRORES RECURRENTES
const ERR_ALBUM_NO_ENCONTRADO = "Álbum no encontrado"

type AlbumesAPI struct {
	DB *sql.DB
}

// Get /albums
// Listar todos los álbumes
func (api *AlbumesAPI) AlbumsGet(c *gin.Context) {
	// Si se pasa el query param `artista`, filtrar por artista
	artistaParam := c.Query("artista")
	if artistaParam != "" {
		api.getAlbumsByArtist(c, artistaParam)
		return
	}

	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, a.precio, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		ORDER BY a.nombre
	`

	rows, err := api.DB.Query(query)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar los álbumes: " + err.Error()})
		return
	}
	defer rows.Close()

	var albums []Album
	for rows.Next() {
		var album Album
		var duracion sql.NullInt32
		var generoID sql.NullInt32
		var generoNombre sql.NullString
		var precio sql.NullFloat64

		err := rows.Scan(
			&album.Id,
			&album.Nombre,
			&duracion,
			&album.Imagen,
			&album.Fecha,
			&generoID,
			&album.Artista,
			&precio,
			&generoNombre,
		)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al leer los datos de los álbumes"})
			return
		}

		if duracion.Valid {
			album.Duracion = duracion.Int32
		}

		if precio.Valid {
			album.Precio = float32(precio.Float64)
		}

		if generoID.Valid {
			album.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}

		albums = append(albums, album)
	}

	if len(albums) == 0 {
		c.JSON(http.StatusOK, []Album{})
		return
	}

	c.JSON(http.StatusOK, albums)
}

// Get /albums/:id
// Obtener detalles de un álbum
func (api *AlbumesAPI) AlbumsIdGet(c *gin.Context) {
	idParam := c.Param("id")

	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, a.precio, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		WHERE a.id = $1
	`

	var album Album
	var duracion sql.NullInt32
	var generoID sql.NullInt32
	var generoNombre sql.NullString
	var precio sql.NullFloat64

	err := api.DB.QueryRow(query, idParam).Scan(
		&album.Id,
		&album.Nombre,
		&duracion,
		&album.Imagen,
		&album.Fecha,
		&generoID,
		&album.Artista,
		&precio,
		&generoNombre,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": ERR_ALBUM_NO_ENCONTRADO})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar el álbum: " + err.Error()})
		return
	}

	if duracion.Valid {
		album.Duracion = duracion.Int32
	}

	if precio.Valid {
		album.Precio = float32(precio.Float64)
	}

	if generoID.Valid {
		album.Genero = Genero{
			Id:     generoID.Int32,
			Nombre: generoNombre.String,
		}
	}

	c.JSON(http.StatusOK, album)
}

// Post /albums
// Crear un nuevo álbum
func (api *AlbumesAPI) AlbumsPost(c *gin.Context) {
	var req CreateAlbumRequest

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Datos de entrada inválidos: " + err.Error()})
		return
	}

	// Validar campos requeridos
	if req.Nombre == "" || req.Artista == 0 || req.Precio <= 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Faltan campos requeridos: nombre, artista, precio (debe ser mayor a 0)"})
		return
	}

	// Iniciar transacción
	tx, err := api.DB.Begin()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al iniciar transacción: " + err.Error()})
		return
	}
	defer tx.Rollback()

	// Insertar nuevo álbum
	albumQuery := `
		INSERT INTO album (nombre, duracion, imagen, fecha, genero, artista, precio)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		RETURNING id, nombre, duracion, imagen, fecha, genero, artista, precio
	`

	var nuevoAlbum Album
	var duracion sql.NullInt32
	var generoID sql.NullInt32
	var precio sql.NullFloat64

	err = tx.QueryRow(
		albumQuery,
		req.Nombre,
		req.Duracion,
		req.Imagen,
		req.Fecha,
		req.Genero,
		req.Artista,
		req.Precio,
	).Scan(
		&nuevoAlbum.Id,
		&nuevoAlbum.Nombre,
		&duracion,
		&nuevoAlbum.Imagen,
		&nuevoAlbum.Fecha,
		&generoID,
		&nuevoAlbum.Artista,
		&precio,
	)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al crear el álbum: " + err.Error()})
		return
	}

	// Insertar relación en album_formato (siempre Formato Digital, Id 1)
	formatoQuery := `
		INSERT INTO album_formato (album, formato)
		VALUES ($1, $2)
	`

	_, err = tx.Exec(formatoQuery, nuevoAlbum.Id, 1) // Siempre formato Digital (ID 1)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al asignar formato al álbum: " + err.Error()})
		return
	}

	// Confirmar transacción
	if err := tx.Commit(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al confirmar transacción: " + err.Error()})
		return
	}

	// Procesar datos del álbum creado
	if duracion.Valid {
		nuevoAlbum.Duracion = duracion.Int32
	}

	if precio.Valid {
		nuevoAlbum.Precio = float32(precio.Float64)
	}

	if generoID.Valid {
		var generoNombre sql.NullString
		err := api.DB.QueryRow("SELECT nombre FROM genero WHERE id = $1", generoID.Int32).Scan(&generoNombre)
		if err == nil && generoNombre.Valid {
			nuevoAlbum.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}
	}

	c.JSON(http.StatusCreated, nuevoAlbum)
}

// Patch /albums/:id
// Actualizar datos de un álbum
func (api *AlbumesAPI) AlbumsIdPatch(c *gin.Context) {
	idParam := c.Param("id")

	var req UpdateAlbumRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Datos de entrada inválidos: " + err.Error()})
		return
	}

	// Verificar que el álbum existe
	if !api.albumExists(idParam) {
		c.JSON(http.StatusNotFound, gin.H{"error": ERR_ALBUM_NO_ENCONTRADO})
		return
	}

	// Construir y ejecutar la actualización
	albumActualizado, err := api.updateAlbum(idParam, req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al actualizar el álbum: " + err.Error()})
		return
	}

	// Añadir datos del género si es necesario
	albumActualizado = api.addGenre(albumActualizado)

	c.JSON(http.StatusOK, albumActualizado)
}

// Función auxiliar para verificar si un álbum existe
func (api *AlbumesAPI) albumExists(id string) bool {
	query := `SELECT id FROM album WHERE id = $1`
	var idInt int
	err := api.DB.QueryRow(query, id).Scan(&idInt)
	return err == nil
}

// Función auxiliar para construir y ejecutar la actualización
func (api *AlbumesAPI) updateAlbum(idParam string, req UpdateAlbumRequest) (Album, error) {
	query, params := buildUpdateQuery(req)
	if len(params) == 0 {
		return Album{}, fmt.Errorf("no se proporcionaron campos para actualizar")
	}

	query += fmt.Sprintf(" WHERE id=$%d RETURNING id, nombre, duracion, imagen, fecha, genero, artista, precio", len(params)+1)
	params = append(params, idParam)

	var album Album
	var duracion sql.NullInt32
	var generoID sql.NullInt32
	var precio sql.NullFloat64

	err := api.DB.QueryRow(query, params...).Scan(
		&album.Id,
		&album.Nombre,
		&duracion,
		&album.Imagen,
		&album.Fecha,
		&generoID,
		&album.Artista,
		&precio,
	)

	if err != nil {
		return Album{}, err
	}

	if duracion.Valid {
		album.Duracion = duracion.Int32
	}

	if precio.Valid {
		album.Precio = float32(precio.Float64)
	}

	return album, nil
}

// Función auxiliar para construir la query de actualización
func buildUpdateQuery(req UpdateAlbumRequest) (string, []any) {
	query := "UPDATE album SET"
	params := []any{}
	i := 1

	addField := func(condition bool, fieldName string, value any) {
		if condition {
			query += fmt.Sprintf(" %s=$%d,", fieldName, i)
			params = append(params, value)
			i++
		}
	}

	addField(req.Nombre != nil, "nombre", *req.Nombre)
	addField(req.Duracion != nil, "duracion", *req.Duracion)
	addField(req.Imagen != nil, "imagen", *req.Imagen)
	addField(req.Fecha != nil, "fecha", *req.Fecha)
	addField(req.Genero != nil, "genero", *req.Genero)
	addField(req.Artista != nil, "artista", *req.Artista)
	addField(req.Precio != nil, "precio", *req.Precio)

	// Eliminar la última coma si hay parámetros
	if len(params) > 0 {
		query = query[:len(query)-1]
	}

	return query, params
}

// Función auxiliar para enriquecer el álbum con información del género
func (api *AlbumesAPI) addGenre(album Album) Album {
	if album.Genero.Id > 0 {
		var generoNombre sql.NullString
		err := api.DB.QueryRow("SELECT nombre FROM genero WHERE id = $1", album.Genero.Id).Scan(&generoNombre)
		if err == nil && generoNombre.Valid {
			album.Genero = Genero{
				Id:     album.Genero.Id,
				Nombre: generoNombre.String,
			}
		}
	}
	return album
}

// Delete /albums/:id
// Eliminar un álbum
func (api *AlbumesAPI) AlbumsIdDelete(c *gin.Context) {
	idParam := c.Param("id")

	// Verificar que el álbum existe
	verificacion := `SELECT id FROM album WHERE id = $1`
	var id int
	err := api.DB.QueryRow(verificacion, idParam).Scan(&id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": ERR_ALBUM_NO_ENCONTRADO})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al verificar el álbum: " + err.Error()})
		return
	}

	// Eliminar el álbum
	eliminacion := `DELETE FROM album WHERE id = $1`
	_, err = api.DB.Exec(eliminacion, idParam)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al eliminar el álbum: " + err.Error()})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

// Función auxiliar para obtener álbumes por artista
func (api *AlbumesAPI) getAlbumsByArtist(c *gin.Context, artistaParam string) {
	artistaID, err := strconv.Atoi(artistaParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Parámetro 'artista' inválido"})
		return
	}

	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, a.precio, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		WHERE a.artista = $1
		ORDER BY a.nombre
	`

	rows, err := api.DB.Query(query, artistaID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar los álbumes del artista: " + err.Error()})
		return
	}
	defer rows.Close()

	var albums []Album
	for rows.Next() {
		var album Album
		var duracion sql.NullInt32
		var generoID sql.NullInt32
		var generoNombre sql.NullString
		var precio sql.NullFloat64

		err := rows.Scan(
			&album.Id,
			&album.Nombre,
			&duracion,
			&album.Imagen,
			&album.Fecha,
			&generoID,
			&album.Artista,
			&precio,
			&generoNombre,
		)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al leer los datos de los álbumes del artista"})
			return
		}

		if duracion.Valid {
			album.Duracion = duracion.Int32
		}

		if precio.Valid {
			album.Precio = float32(precio.Float64)
		}

		if generoID.Valid {
			album.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}

		albums = append(albums, album)
	}

	if len(albums) == 0 {
		c.JSON(http.StatusOK, []Album{})
		return
	}

	c.JSON(http.StatusOK, albums)
}

// Get /albums/:id/detalle
// Obtener detalles completos de un álbum incluyendo sus canciones e información del artista
func (api *AlbumesAPI) AlbumsIdDetalleGet(c *gin.Context) {
	idParam := c.Param("id")

	// Obtener información básica del álbum
	albumBase, err := api.obtenerAlbumBase(idParam)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": ERR_ALBUM_NO_ENCONTRADO})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar el álbum: " + err.Error()})
		return
	}

	// Obtener canciones del álbum
	canciones, err := api.obtenerCancionesAlbum(idParam)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar las canciones del álbum: " + err.Error()})
		return
	}

	// Construir la respuesta final
	albumDetalle := api.construirAlbumDetalle(albumBase, canciones)

	c.JSON(http.StatusOK, albumDetalle)
}

// Estructura auxiliar para datos base del álbum
type albumBaseData struct {
	ID              int32
	Nombre          string
	DuracionSegundos sql.NullInt32
	Imagen          string
	Fecha           string
	GeneroID        sql.NullInt32
	GeneroNombre    sql.NullString
	ArtistaID       int32
	Precio          sql.NullFloat64
}

// Función auxiliar para obtener datos base del álbum
func (api *AlbumesAPI) obtenerAlbumBase(idParam string) (albumBaseData, error) {
	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, a.precio, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		WHERE a.id = $1
	`

	var data albumBaseData
	err := api.DB.QueryRow(query, idParam).Scan(
		&data.ID,
		&data.Nombre,
		&data.DuracionSegundos,
		&data.Imagen,
		&data.Fecha,
		&data.GeneroID,
		&data.ArtistaID,
		&data.Precio,
		&data.GeneroNombre,
	)

	return data, err
}

// Función auxiliar para obtener canciones del álbum
func (api *AlbumesAPI) obtenerCancionesAlbum(idParam string) ([]Cancion, error) {
	query := `
		SELECT id, nombre, duracion, album
		FROM cancion
		WHERE album = $1
		ORDER BY id
	`

	rows, err := api.DB.Query(query, idParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var canciones []Cancion
	for rows.Next() {
		var cancion Cancion
		var duracion int

		err := rows.Scan(
			&cancion.Id,
			&cancion.Nombre,
			&duracion,
			&cancion.Album,
		)

		if err != nil {
			return nil, err
		}

		cancion.Duracion = formatDuracion(duracion)
		canciones = append(canciones, cancion)
	}

	return canciones, nil
}

// Función auxiliar para construir el AlbumDetalle final
func (api *AlbumesAPI) construirAlbumDetalle(data albumBaseData, canciones []Cancion) AlbumDetalle {
	// Obtener nombre del artista
	artistaNombre, _ := ObtenerNombreUsuario(data.ArtistaID)
	if artistaNombre == "" {
		artistaNombre = "Artista Desconocido"
	}

	// Construir objeto base
	albumDetalle := AlbumDetalle{
		Id:            data.ID,
		Nombre:        data.Nombre,
		Fecha:         data.Fecha,
		Artista:       data.ArtistaID,
		NombreArtista: artistaNombre,
		Canciones:     canciones,
		Imagen:        data.Imagen,
	}

	// Procesar duración
	albumDetalle = api.procesarDuracion(albumDetalle, data.DuracionSegundos, canciones)

	// Procesar género
	albumDetalle = api.procesarGenero(albumDetalle, data.GeneroID, data.GeneroNombre)

	// Procesar precio
	albumDetalle = api.procesarPrecio(albumDetalle, data.Precio)

	return albumDetalle
}

// Funciones auxiliares para procesar campos específicos
func (api *AlbumesAPI) procesarDuracion(albumDetalle AlbumDetalle, duracionSegundos sql.NullInt32, canciones []Cancion) AlbumDetalle {
	if duracionSegundos.Valid {
		albumDetalle.Duracion = formatDuracion(int(duracionSegundos.Int32))
	} else {
		// Calcular duración total sumando las canciones
		duracionTotal := 0
		for _, cancion := range canciones {
			segundos, err := parseDuracion(cancion.Duracion)
			if err == nil {
				duracionTotal += segundos
			}
		}
		albumDetalle.Duracion = formatDuracion(duracionTotal)
	}
	return albumDetalle
}

func (api *AlbumesAPI) procesarGenero(albumDetalle AlbumDetalle, generoID sql.NullInt32, generoNombre sql.NullString) AlbumDetalle {
	if generoID.Valid {
		albumDetalle.Genero = Genero{
			Id:     generoID.Int32,
			Nombre: generoNombre.String,
		}
	}
	return albumDetalle
}

func (api *AlbumesAPI) procesarPrecio(albumDetalle AlbumDetalle, precio sql.NullFloat64) AlbumDetalle {
	if precio.Valid {
		albumDetalle.Precio = float32(precio.Float64)
	}
	return albumDetalle
}

// Get /albums/:id/imagen
// Obtener la imagen del álbum
func (api *AlbumesAPI) AlbumsIdImagenGet(c *gin.Context) {
	idParam := c.Param("id")

	query := `
		SELECT imagen, nombre
		FROM album
		WHERE id = $1
	`

	var imagen []byte
	var nombre string

	err := api.DB.QueryRow(query, idParam).Scan(&imagen, &nombre)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": ERR_ALBUM_NO_ENCONTRADO})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar la imagen del álbum: " + err.Error()})
		return
	}

	if len(imagen) == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Imagen no disponible"})
		return
	}

	// Determinar el tipo de imagen basado en los primeros bytes
	contentType := http.DetectContentType(imagen)
	
	// Configurar headers para la respuesta de imagen
	c.Header("Content-Type", contentType)
	c.Header("Content-Disposition", fmt.Sprintf("inline; filename=\"%s.jpg\"", nombre))
	c.Header("Content-Length", fmt.Sprintf("%d", len(imagen)))
	
	// Enviar la imagen
	c.Data(http.StatusOK, contentType, imagen)
}
