/*
 * Microservicio de Contenido - UnderSounds
 *
 * Este microservicio gestiona el contenido multimedia y comercial del proyecto \"UnderSounds\", incluyendo albumes, canciones, generos, merchandising y noticias musicales.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

type AlbumesAPI struct {
	DB *sql.DB
}

// Get /albums
// Listar todos los álbumes
func (api *AlbumesAPI) AlbumsGet(c *gin.Context) {
	// Si se pasa el query param `artista`, filtrar por artista
	artistaParam := c.Query("artista")
	if artistaParam != "" {
		api.getAlbumsByArtist(c, artistaParam)
		return
	}

	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		ORDER BY a.nombre
	`

	rows, err := api.DB.Query(query)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar los álbumes: " + err.Error()})
		return
	}
	defer rows.Close()

	var albums []Album
	for rows.Next() {
		var album Album
		var duracion sql.NullInt32
		var generoID sql.NullInt32
		var generoNombre sql.NullString

		err := rows.Scan(
			&album.Id,
			&album.Nombre,
			&duracion,
			&album.Imagen,
			&album.Fecha,
			&generoID,
			&album.Artista,
			&generoNombre,
		)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al leer los datos de los álbumes"})
			return
		}

		if duracion.Valid {
			album.Duracion = duracion.Int32
		}

		if generoID.Valid {
			album.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}

		albums = append(albums, album)
	}

	if len(albums) == 0 {
		c.JSON(http.StatusOK, []Album{})
		return
	}

	c.JSON(http.StatusOK, albums)
}

// Get /albums/:id
// Obtener detalles de un álbum
func (api *AlbumesAPI) AlbumsIdGet(c *gin.Context) {
	idParam := c.Param("id")

	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		WHERE a.id = $1
	`

	var album Album
	var duracion sql.NullInt32
	var generoID sql.NullInt32
	var generoNombre sql.NullString

	err := api.DB.QueryRow(query, idParam).Scan(
		&album.Id,
		&album.Nombre,
		&duracion,
		&album.Imagen,
		&album.Fecha,
		&generoID,
		&album.Artista,
		&generoNombre,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Álbum no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar el álbum: " + err.Error()})
		return
	}

	if duracion.Valid {
		album.Duracion = duracion.Int32
	}

	if generoID.Valid {
		album.Genero = Genero{
			Id:     generoID.Int32,
			Nombre: generoNombre.String,
		}
	}

	c.JSON(http.StatusOK, album)
}

// Post /albums
// Crear un nuevo álbum
func (api *AlbumesAPI) AlbumsPost(c *gin.Context) {
	var req CreateAlbumRequest

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Datos de entrada inválidos: " + err.Error()})
		return
	}

	// Validar campos requeridos
	if req.Nombre == "" || req.Artista == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Faltan campos requeridos: nombre, artista"})
		return
	}

	// Insertar nuevo álbum
	query := `
		INSERT INTO album (nombre, duracion, imagen, fecha, genero, artista)
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id, nombre, duracion, imagen, fecha, genero, artista
	`

	var nuevoAlbum Album
	var duracion sql.NullInt32
	var generoID sql.NullInt32

	err := api.DB.QueryRow(
		query,
		req.Nombre,
		req.Duracion,
		req.Imagen,
		req.Fecha,
		req.Genero,
		req.Artista,
	).Scan(
		&nuevoAlbum.Id,
		&nuevoAlbum.Nombre,
		&duracion,
		&nuevoAlbum.Imagen,
		&nuevoAlbum.Fecha,
		&generoID,
		&nuevoAlbum.Artista,
	)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al crear el álbum: " + err.Error()})
		return
	}

	if duracion.Valid {
		nuevoAlbum.Duracion = duracion.Int32
	}

	if generoID.Valid {
		var generoNombre sql.NullString
		err := api.DB.QueryRow("SELECT nombre FROM genero WHERE id = $1", generoID.Int32).Scan(&generoNombre)
		if err == nil && generoNombre.Valid {
			nuevoAlbum.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}
	}

	c.JSON(http.StatusCreated, nuevoAlbum)
}

// Patch /albums/:id
// Actualizar datos de un álbum
func (api *AlbumesAPI) AlbumsIdPatch(c *gin.Context) {
	idParam := c.Param("id")

	var req UpdateAlbumRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Datos de entrada inválidos: " + err.Error()})
		return
	}

	// Verificar que el álbum existe
	verificacion := `SELECT id FROM album WHERE id = $1`
	var id int
	err := api.DB.QueryRow(verificacion, idParam).Scan(&id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Álbum no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al verificar el álbum: " + err.Error()})
		return
	}

	// Construir query dinámica
	query := "UPDATE album SET"
	params := []interface{}{}
	i := 1

	if req.Nombre != nil {
		query += fmt.Sprintf(" nombre=$%d,", i)
		params = append(params, *req.Nombre)
		i++
	}
	if req.Duracion != nil {
		query += fmt.Sprintf(" duracion=$%d,", i)
		params = append(params, *req.Duracion)
		i++
	}
	if req.Imagen != nil {
		query += fmt.Sprintf(" imagen=$%d,", i)
		params = append(params, *req.Imagen)
		i++
	}
	if req.Fecha != nil {
		query += fmt.Sprintf(" fecha=$%d,", i)
		params = append(params, *req.Fecha)
		i++
	}
	if req.Genero != nil {
		query += fmt.Sprintf(" genero=$%d,", i)
		params = append(params, *req.Genero)
		i++
	}
	if req.Artista != nil {
		query += fmt.Sprintf(" artista=$%d,", i)
		params = append(params, *req.Artista)
		i++
	}

	if len(params) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No se proporcionaron campos para actualizar"})
		return
	}

	query = query[:len(query)-1] + fmt.Sprintf(" WHERE id=$%d RETURNING id, nombre, duracion, imagen, fecha, genero, artista", i)
	params = append(params, idParam)

	var albumActualizado Album
	var duracion sql.NullInt32
	var generoID sql.NullInt32

	err = api.DB.QueryRow(query, params...).Scan(
		&albumActualizado.Id,
		&albumActualizado.Nombre,
		&duracion,
		&albumActualizado.Imagen,
		&albumActualizado.Fecha,
		&generoID,
		&albumActualizado.Artista,
	)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al actualizar el álbum: " + err.Error()})
		return
	}

	if duracion.Valid {
		albumActualizado.Duracion = duracion.Int32
	}

	if generoID.Valid {
		var generoNombre sql.NullString
		err := api.DB.QueryRow("SELECT nombre FROM genero WHERE id = $1", generoID.Int32).Scan(&generoNombre)
		if err == nil && generoNombre.Valid {
			albumActualizado.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}
	}

	c.JSON(http.StatusOK, albumActualizado)
}

// Delete /albums/:id
// Eliminar un álbum
func (api *AlbumesAPI) AlbumsIdDelete(c *gin.Context) {
	idParam := c.Param("id")

	// Verificar que el álbum existe
	verificacion := `SELECT id FROM album WHERE id = $1`
	var id int
	err := api.DB.QueryRow(verificacion, idParam).Scan(&id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"error": "Álbum no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al verificar el álbum: " + err.Error()})
		return
	}

	// Eliminar el álbum
	eliminacion := `DELETE FROM album WHERE id = $1`
	_, err = api.DB.Exec(eliminacion, idParam)

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al eliminar el álbum: " + err.Error()})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

// Función auxiliar para obtener álbumes por artista
func (api *AlbumesAPI) getAlbumsByArtist(c *gin.Context, artistaParam string) {
	artistaID, err := strconv.Atoi(artistaParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Parámetro 'artista' inválido"})
		return
	}

	query := `
		SELECT a.id, a.nombre, a.duracion, a.imagen, a.fecha, a.genero, a.artista, g.nombre as genero_nombre
		FROM album a
		LEFT JOIN genero g ON a.genero = g.id
		WHERE a.artista = $1
		ORDER BY a.nombre
	`

	rows, err := api.DB.Query(query, artistaID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al consultar los álbumes del artista: " + err.Error()})
		return
	}
	defer rows.Close()

	var albums []Album
	for rows.Next() {
		var album Album
		var duracion sql.NullInt32
		var generoID sql.NullInt32
		var generoNombre sql.NullString

		err := rows.Scan(
			&album.Id,
			&album.Nombre,
			&duracion,
			&album.Imagen,
			&album.Fecha,
			&generoID,
			&album.Artista,
			&generoNombre,
		)

		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Error al leer los datos de los álbumes del artista"})
			return
		}

		if duracion.Valid {
			album.Duracion = duracion.Int32
		}

		if generoID.Valid {
			album.Genero = Genero{
				Id:     generoID.Int32,
				Nombre: generoNombre.String,
			}
		}

		albums = append(albums, album)
	}

	if len(albums) == 0 {
		c.JSON(http.StatusOK, []Album{})
		return
	}

	c.JSON(http.StatusOK, albums)
}
