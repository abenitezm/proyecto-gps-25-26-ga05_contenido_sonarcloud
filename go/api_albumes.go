/*
 * Microservicio de Contenido - UnderSounds
 *
 * Este microservicio gestiona el contenido multimedia y comercial del proyecto \"UnderSounds\", incluyendo albumes, canciones, generos, merchandising y noticias musicales.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"database/sql"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

type AlbumesAPI struct {
	DB *sql.DB
}

// Get /albums
// Listar albumes con filtros opcionales
func (api *AlbumesAPI) AlbumsGet(c *gin.Context) {
	// Si se pasa el query param `artista`, filtrar por artista
	artistaParam := c.Query("artista")
	if artistaParam != "" {
		v, err := strconv.Atoi(artistaParam)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "parámetro 'artista' inválido"})
			return
		}
		albums, err := GetAlbumsByArtist(api.DB, int32(v))
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		c.JSON(http.StatusOK, gin.H{
			"status": "OK",
			"albums": albums,
		})
		return
	}

	albums, err := GetAllAlbums(api.DB)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"status": "OK",
		"albums": albums,
	})
}

// Delete /albums/:id
// Eliminar un album
func (api *AlbumesAPI) AlbumsIdDelete(c *gin.Context) {
	idParam := c.Param("id")
	var id int32
	_, err := fmt.Sscan(idParam, &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
		return
	}

	err = DeleteAlbum(api.DB, id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"status": "error", "message": "Album no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status":  "OK",
		"message": "Album eliminado correctamente",
	})
}

// Patch /albums/:id/disminuirStockAlbum
// Disminuir la cantidad disponible de un album
func (api *AlbumesAPI) AlbumsIdDisminuirStockAlbumPatch(c *gin.Context) {
	// Your handler implementation
	c.JSON(http.StatusNotImplemented, gin.H{"status": "not_implemented"})
}

// Get /albums/:id
// Obtener detalles de un album
func (api *AlbumesAPI) AlbumsIdGet(c *gin.Context) {
	idParam := c.Param("id")
	var id int32
	_, err := fmt.Sscan(idParam, &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
		return
	}

	album, err := GetAlbum(api.DB, id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"status": "error", "message": "Album no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status": "OK",
		"album":  album,
	})
}

// Patch /albums/:id
// Actualizar un album existente
func (api *AlbumesAPI) AlbumsIdPatch(c *gin.Context) {
	idParam := c.Param("id")
	var id int32
	_, err := fmt.Sscan(idParam, &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
		return
	}

	// Leer body JSON
	var req UpdateAlbumRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON inválido"})
		return
	}

	// Llamada al modelo
	updatedAlbum, err := req.UpdateAlbum(api.DB, id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"status": "error", "message": "Album no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	// Respuesta exitosa
	c.JSON(http.StatusOK, gin.H{
		"status": "OK",
		"album":  updatedAlbum,
	})
}

// Patch /albums/:id/recargarStockAlbum
// Aumentar la cantidad disponible de un album
func (api *AlbumesAPI) AlbumsIdRecargarStockAlbumPatch(c *gin.Context) {
	// Your handler implementation
	c.JSON(http.StatusNotImplemented, gin.H{"status": "not_implemented"})
}

// Post /albums
// Crear un nuevo album
func (api *AlbumesAPI) AlbumsPost(c *gin.Context) {
	var req CreateAlbumRequest

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "JSON inválido"})
		return
	}
	// Crear album en la BD
	nuevoAlbum, err := req.CreateAlbum(api.DB)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	c.JSON(http.StatusCreated, gin.H{
		"status": "OK",
		"album":  nuevoAlbum,
	})
}
