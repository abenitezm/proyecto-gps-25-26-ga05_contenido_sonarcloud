/*
 * Microservicio de Contenido - UnderSounds
 *
 * Este microservicio gestiona el contenido multimedia y comercial del proyecto \"UnderSounds\", incluyendo albumes, canciones, generos, merchandising y noticias musicales.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"database/sql"
	"fmt"
)

type Merch struct {
	Id        int32   `json:"id,omitempty"`
	Nombre    string  `json:"nombre"`
	Precio    float32 `json:"precio"`
	UrlImagen string  `json:"urlImagen"`
	Artista   int32   `json:"artista"`
	Stock     int32   `json:"stock"`
}

type CreateMerchRequest struct {
	Nombre    string  `json:"nombre" binding:"required"`
	Precio    float32 `json:"precio" binding:"required"`
	UrlImagen string  `json:"urlImagen"`
	Artista   int32   `json:"artista"`
	Stock     int32   `json:"stock"`
}

type UpdateMerchRequest struct {
	Nombre    *string  `json:"nombre"`
	Precio    *float32 `json:"precio"`
	UrlImagen *string  `json:"urlImagen"`
	Artista   *int32   `json:"artista"`
	Stock     *int32   `json:"stock"`
}

func GetAllMerch(db *sql.DB) ([]Merch, error) {
	rows, err := db.Query("SELECT id, nombre, precio, urlimagen, artista, stock FROM merchandising")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var merchs []Merch
	for rows.Next() {
		var m Merch
		if err := rows.Scan(&m.Id, &m.Nombre, &m.Precio, &m.UrlImagen, &m.Artista, &m.Stock); err != nil {
			return nil, err
		}
		merchs = append(merchs, m)
	}
	return merchs, nil
}

func DeleteMerch(db *sql.DB, id int32) error {
	result, err := db.Exec("DELETE FROM merchandising WHERE id = $1", id)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func GetMerch(db *sql.DB, id int32) (*Merch, error) {
	var m Merch
	err := db.QueryRow(
		"SELECT id, nombre, precio, urlimagen, artista, stock FROM merchandising WHERE id = $1",
		id,
	).Scan(&m.Id, &m.Nombre, &m.Precio, &m.UrlImagen, &m.Artista, &m.Stock)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, err
	}

	return &m, nil
}

func (m *CreateMerchRequest) CreateMerch(db *sql.DB) (*Merch, error) {
	var nuevo Merch
	query := `
	INSERT INTO merchandising (nombre,precio,urlimagen,artista,stock)
	VALUES ($1, $2, $3, $4, $5)
	RETURNING id, nombre, precio, urlimagen, artista, stock
	`

	err := db.QueryRow(query, m.Nombre, m.Precio, m.UrlImagen, m.Artista, m.Stock).
		Scan(&nuevo.Id, &nuevo.Nombre, &nuevo.Precio, &nuevo.UrlImagen, &nuevo.Artista, &nuevo.Stock)
	if err != nil {
		return nil, err
	}
	return &nuevo, nil
}

func (u *UpdateMerchRequest) UpdateMerch(db *sql.DB, id int32) (*Merch, error) {
	query := "UPDATE merchandising SET"
	params := []interface{}{}
	i := 1

	if u.Nombre != nil {
		query += fmt.Sprintf("nombre=$%d,", i)
		params = append(params, *u.Nombre)
		i++
	}
	if u.Precio != nil {
		query += fmt.Sprintf("precio=$%d,", i)
		params = append(params, *u.Precio)
		i++
	}
	if u.UrlImagen != nil {
		query += fmt.Sprintf("urlimagen=$%d,", i)
		params = append(params, *u.UrlImagen)
		i++
	}
	if u.Artista != nil {
		query += fmt.Sprintf("artista=$%d,", i)
		params = append(params, *u.Artista)
		i++
	}
	if u.Stock != nil {
		query += fmt.Sprintf("stock=$%d,", i)
		params = append(params, *u.Stock)
		i++
	}

	if len(params) == 0 {
		return nil, fmt.Errorf("no se introducen campos para actualizar")
	}

	query = query[:len(query)-1] + fmt.Sprintf(" WHERE id=$%d RETURNING id, nombre, precio, urlimagen, artista, stock", i)
	params = append(params, id)

	var updated Merch
	err := db.QueryRow(query, params...).Scan(
		&updated.Id, &updated.Nombre, &updated.Precio, &updated.UrlImagen, &updated.Artista, &updated.Stock,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, err
	}

	return &updated, nil
}
